# Data Model: Vector Embeddings with Qdrant for RAG

**Phase 1 Output**: Entity definitions and data relationships
**Date**: 2025-12-05

## Entity Definitions

### 1. ChapterChunk

Represents a section of a chapter extracted by markdown parsing.

**Purpose**: Intermediate data structure between markdown files and Qdrant vectors.

**Fields**:

| Field | Type | Description | Validation |
|-------|------|-------------|-----------|
| chapter_id | string | Unique identifier derived from filename (e.g., "ch01") | Required, non-empty, alphanumeric |
| chapter_title | string | Full title of the chapter (e.g., "Introduction to ROS 2") | Required, non-empty, max 200 chars |
| section_number | integer | Sequential section number within chapter (0-indexed) | Required, >= 0 |
| section_title | string | Title of the ## section (e.g., "What is ROS?") | Required, non-empty, max 200 chars |
| content | string | Full text content of the section | Required, non-empty, max 8000 chars (512 tokens) |
| metadata | object | Additional context | Optional, see below |

**Metadata Fields** (optional):
- `source_file`: filepath of markdown source
- `token_count`: number of tokens in content (for OpenAI rate limiting)
- `headers_path`: breadcrumb trail (e.g., ["Introduction to ROS 2", "What is ROS?"]) for RAG context

**Example**:

```json
{
  "chapter_id": "ch03",
  "chapter_title": "Kinematics and Motion Planning",
  "section_number": 2,
  "section_title": "Forward Kinematics",
  "content": "Forward kinematics is the problem of computing the position and orientation of the end-effector given joint angles...",
  "metadata": {
    "source_file": "frontend/docs/chapters/ch03_kinematics.md",
    "token_count": 287,
    "headers_path": ["Kinematics and Motion Planning", "Forward Kinematics"]
  }
}
```

**Validation Rules**:
- content length: 50-8000 characters (safeguard against empty sections and token limit)
- section_number: must be sequential and unique within chapter
- chapter_id: must match filename pattern `ch[0-9]+`

---

### 2. TextEmbedding

Vector representation of a ChapterChunk generated by OpenAI embedding model.

**Purpose**: Vector ready for storage in Qdrant vector database.

**Fields**:

| Field | Type | Description |
|-------|------|-------------|
| chunk_id | string | Unique identifier (format: "{chapter_id}_{section_number}") |
| vector | array[float] | 1536-dimensional embedding vector from OpenAI |
| metadata | object | Chunk metadata for Qdrant payload |

**Metadata Fields** (stored in Qdrant payload):
- `chapter_id`: string - for filtering by chapter
- `section_number`: integer - for filtering by section
- `title`: string - concatenated "{chapter_title} > {section_title}" for RAG context
- `content`: string - full chunk text (enables citation without second lookup)

**Example**:

```json
{
  "chunk_id": "ch03_2",
  "vector": [0.0234, -0.0187, 0.0456, ... 1536 total dimensions],
  "metadata": {
    "chapter_id": "ch03",
    "section_number": 2,
    "title": "Kinematics and Motion Planning > Forward Kinematics",
    "content": "Forward kinematics is the problem of..."
  }
}
```

**Validation Rules**:
- vector: exactly 1536 dimensions, float32 type
- vector values: normalized to [-1, 1] range (OpenAI standard)
- metadata.title: max 256 characters (Qdrant payload limit)
- content: included for RAG response generation (no second lookup needed)

---

### 3. QdrantVector

Final record stored in Qdrant collection (internal Qdrant representation).

**Purpose**: Stored in Qdrant "chapter_embeddings" collection for semantic search.

**Qdrant Schema**:

```python
class QdrantVector(BaseModel):
    id: int  # Qdrant auto-assigned unique ID
    vector: List[float]  # 1536-dimensional embedding
    payload: Dict[str, Any]  # {
                              #   "chapter_id": "ch03",
                              #   "section_number": 2,
                              #   "title": "Kinematics and Motion Planning > Forward Kinematics",
                              #   "content": "Forward kinematics is the problem of..."
                              # }
```

**Qdrant Collection Configuration**:

```
Collection Name: "chapter_embeddings"
Vector Size: 1536
Distance Metric: COSINE
Indexed Fields: ["chapter_id", "section_number", "title"]
```

**Retrieval Pattern** (for RAG):

1. User query converted to 1536-dim embedding (same model)
2. Search Qdrant: `search(query_vector, limit=5, filter={"chapter_id": "ch03"})`
3. Returns top-5 vectors with payloads (includes content for citation)
4. RAG system ranks by similarity score and includes content in LLM prompt

---

### 4. EmbeddingBatch

Intermediate data structure for batch processing OpenAI API requests.

**Purpose**: Groups chunks for efficient API batching (32 chunks per batch).

**Fields**:

| Field | Type | Description |
|-------|------|-------------|
| batch_id | string | Unique batch identifier (UUID or "{chapter}_{batch_num}") |
| chunks | List[ChapterChunk] | 1-32 chunks to embed |
| texts | List[string] | Extracted content from chunks for OpenAI API |
| embeddings | List[List[float]] | Returned embeddings from OpenAI (filled after API call) |
| status | string | "pending", "processing", "success", "failed" |
| retry_count | integer | Number of retry attempts (0-3) |
| error_message | string | If failed: error reason (rate limit, connection, etc.) |

**Example**:

```json
{
  "batch_id": "ch03_batch_1",
  "chunks": [
    { "chapter_id": "ch03", "section_number": 0, ... },
    { "chapter_id": "ch03", "section_number": 1, ... }
  ],
  "texts": [
    "Forward kinematics is...",
    "Inverse kinematics is..."
  ],
  "embeddings": [
    [0.0234, -0.0187, ..., (1536 dims)],
    [0.0125, 0.0456, ..., (1536 dims)]
  ],
  "status": "success",
  "retry_count": 0,
  "error_message": null
}
```

**Validation Rules**:
- chunks.length: 1-32
- texts.length: must equal chunks.length
- embeddings.length: must equal chunks.length after API call
- Each text: 1-8000 characters (OpenAI API constraint)

---

### 5. ProcessingResult

Summary report from end-to-end pipeline execution.

**Purpose**: Report success/failure statistics to administrator.

**Fields**:

| Field | Type | Description |
|-------|------|-------------|
| total_files | integer | Total markdown files processed |
| total_chunks | integer | Total sections extracted |
| successfully_embedded | integer | Chunks with embeddings generated |
| successfully_inserted | integer | Chunks stored in Qdrant |
| failed_files | List[string] | Files that couldn't be parsed |
| failed_chunks | List[object] | Chunks that failed embedding (with reasons) |
| skipped_chunks | integer | Chunks skipped due to validation errors |
| processing_time_seconds | float | Total wall-clock time |
| embedding_api_calls | integer | Total OpenAI API calls made |
| rate_limit_hits | integer | Number of rate limit errors encountered |
| average_chunk_size_tokens | float | Mean chunk size in tokens |
| logs | List[string] | JSON log lines (one per operation) |

**Example**:

```json
{
  "total_files": 100,
  "total_chunks": 524,
  "successfully_embedded": 520,
  "successfully_inserted": 520,
  "failed_files": ["ch45_malformed.md"],
  "failed_chunks": [
    {
      "chunk_id": "ch99_5",
      "reason": "embedding API failed after 3 retries",
      "error": "timeout"
    }
  ],
  "skipped_chunks": 4,
  "processing_time_seconds": 287.5,
  "embedding_api_calls": 17,
  "rate_limit_hits": 3,
  "average_chunk_size_tokens": 245.3,
  "logs": [
    "{\"timestamp\": \"2025-12-05T14:32:10Z\", \"operation\": \"chunk\", \"status\": \"success\", ...}",
    "{\"timestamp\": \"2025-12-05T14:32:12Z\", \"operation\": \"embed\", \"status\": \"success\", ...}"
  ]
}
```

**Validation Rules**:
- successfully_embedded + failed_chunks + skipped_chunks = total_chunks
- successfully_inserted <= successfully_embedded (some embeddings may fail insertion)

---

## Entity Relationships

```
Markdown Files (frontend/docs/chapters/)
    ↓ (parse & chunk)
ChapterChunk (intermediate, in-memory)
    ↓ (batch)
EmbeddingBatch (groups 1-32 chunks)
    ↓ (send to OpenAI API)
TextEmbedding (vector + metadata)
    ↓ (insert into Qdrant)
QdrantVector (stored in "chapter_embeddings" collection)

ProcessingResult (aggregates success/failure statistics)
```

---

## State Transitions

**ChapterChunk States**:
1. `extracted` → Successfully parsed from markdown
2. `batched` → Grouped into EmbeddingBatch
3. `embedding_requested` → Sent to OpenAI API
4. `embedded` → Received 1536-dim vector from OpenAI
5. `qdrant_insert_requested` → Sent to Qdrant insertion
6. `stored` → Successfully stored in Qdrant collection
7. `error` → Failed at any stage (error logged, chunk skipped)

**EmbeddingBatch States**:
1. `pending` → Created, awaiting API call
2. `processing` → API request in flight
3. `success` → All chunks embedded successfully
4. `failed_retrying` → Rate limit or transient error, retrying
5. `failed` → Max retries exhausted, chunks skipped

---

## Database / Storage Mapping

| Entity | Storage Location | Persistence |
|--------|-----------------|-------------|
| Markdown Files | `frontend/docs/chapters/*.md` | Persistent (filesystem) |
| ChapterChunk | In-memory (Python list/dict) | Temporary (session only) |
| EmbeddingBatch | In-memory queue | Temporary (session only) |
| TextEmbedding | In-memory before insertion | Temporary (session only) |
| QdrantVector | Qdrant Cloud collection "chapter_embeddings" | Persistent (vector database) |
| ProcessingResult | Logged to stdout/file (JSON) | Persistent (administrator viewable) |

---

## Constraints & Indexes

**Qdrant Collection Indexes** (for efficient RAG queries):

```python
# Indexed for filtering
indexed_fields = ["chapter_id", "section_number"]

# Example filtered queries:
# - Get all sections from chapter_id="ch03"
# - Get section_number >= 5 from all chapters
# - Combine filters: chapter_id="ch03" AND section_number < 10
```

**Content Size Constraints**:
- Max chunk content: 512 tokens (~2000 characters)
- Max section title: 200 characters
- Max chapter title: 200 characters
- Metadata payload: Qdrant supports arbitrary JSON (no size limit for educational content scale)

**Validation Constraints**:
- Unique constraint: (chapter_id, section_number) pair is unique in Qdrant
- Required fields: chapter_id, section_number, title, content
- Non-empty: all string fields must have content
- Ordering: section_numbers must be sequential (0-indexed) within chapter
